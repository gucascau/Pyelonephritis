---
title: "PipseqPTSubcluster_V0822"
author: "Xin Wang"
date: "2023-08-22"
description: Proximal tubule subclusters analyses:
  - Subclusters of PT
  - Annotation of subclusters using the candidate markers
  - Psudotime of PT using monocle2, instead of monocle3
  - Basic statistics of PT
output: html_document
---
# Loading the packages
```{r}
# check the session information
sessionInfo()
library(dplyr)
library(Seurat)
library(patchwork)

#install.packages('devtools') #assuming it is not already installed

if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
library(devtools)
#install_github('andreacirilloac/updateR')
# install.packages("sctransform")
# install.packages("ggthemes")
# loading the libarary
library(updateR)

library("sctransform")
library("ggthemes")
library(Seurat)

# BiocManager::install("limma")
# BiocManager::install("ComplexHeatmap")
# BiocManager::install("biomaRt")
# BiocManager::install("methrix")BiocManager::install("org.Hs.eg.db")
# devtools::install_github("saeyslab/nichenetr")
library(limma)
library(nichenetr)
library(tidyverse)
library(dplyr)

library(biomaRt)
library("data.table")


library(umap)
library(patchwork)
library(cowplot)
library(installr)

#install.packages("Matrix", repos = "http://cran.r-project.org")
### we used discre color palettes from ggsci

library("ggsci")
library("ggplot2")
library("gridExtra")

#options(buildtools.check = function(action) TRUE )
#devtools::install_url('https://cran.r-project.org/src/contrib/Archive/Matrix.utils/Matrix.utils_0.9.7.tar.gz')
#devtools::install_github('cole-trapnell-lab/monocle3')
#library(monocle3)

library(harmony)
library(Seurat)
#library(SeuratData)
library(tidyverse)

#library(BPCells)
library(ggplot2)
library("devtools")
library("AnnotationDbi")
library("org.Hs.eg.db")
#library(tibble)
#library(future)
library(here)
library(patchwork)
library(future)
#source("http://bioconductor.org/biocLite.R")
#biocLite("monocle")

#library(monocle3)

# install monocle

#BiocManager::install("monocle",force = TRUE)
library(monocle)
#devtools::install_dev("remotes")
#remotes::install_github('chris-mcginnis-ucsf/DoubletFinder')
#remotes::install_github(repo ='chris-mcginnis-ucsf/DoubletFinder' )
#install.packages("DoubletFinder")
library(DoubletFinder)
library(future.callr)
library(ComplexHeatmap)

library(RColorBrewer)
library(circlize)
library(monocle3)
#install.packages("magick")
library(magick)
#K means with 6 groups
library("scCustomize")

```


## Step 2: Set up the workspace environment:
```{r}
rm(list=ls())
setwd("/Users/XXW004/Documents/Projects/RuizRosado/PIPseq/Results/Evaluation_V022723/CellEvaluation_Subclustering_V0803/PT_Subclusters/")
Indir <-c("/Users/XXW004/Documents/Projects/RuizRosado/PIPseq/Results/Evaluation_V022723/CellEvaluation_Subclustering_V0803/")
Outdir <-c( "/Users/XXW004/Documents/Projects/RuizRosado/PIPseq/Results/Evaluation_V022723/CellEvaluation_Subclustering_V0803/PT_Subclusters/")
# setting up the seed 
set.seed(10000)
```

# Create 
```{r}
# create folders for DEGs, Progeny, GO, KEGG and TF analyses
# directory for DEGs
DEGDir <- paste0(Outdir,"DEGs/")
# directory for Progeny
ProgenyDir <- paste0(Outdir,"Progeny/")
# directory for GO enrichments
GOenrichDir <- paste0(Outdir,"GOenrich/")
# directory for Transcript Factors
TFDir <-  paste0(Outdir,"TranscriptFactors/")
# directory for KEGG
KEGGDir <-  paste0(Outdir,"KEGG/")
# directory for CellCommunication
CellCommDir <-  paste0(Outdir,"CellCommunication/")
# directory for pyseudotime
PyseudotimeDir <-  paste0(Outdir,"PyseudotimeMonocle2/")

# directory for biomarkers

BioMarkerDir <- paste0(Outdir,"Biomarkers/")

dir.create(DEGDir, showWarnings = FALSE)
dir.create(ProgenyDir, showWarnings = FALSE)
dir.create(GOenrichDir, showWarnings = FALSE)
dir.create(TFDir, showWarnings = FALSE)
dir.create(KEGGDir, showWarnings = FALSE)
dir.create(CellCommDir, showWarnings = FALSE)
dir.create(BioMarkerDir, showWarnings = FALSE)
dir.create(PyseudotimeDir, showWarnings = FALSE)

set.seed(10000)
```
# generate the health cluster of PT cells

```{r}

# Read the preclustered object

scrna <- readRDS(file = paste0(Indir,"Pyelonephritis_singlecell_harmony_withAnnotation_v0803.RDS"))

# When you analyse the details please ignore the following analyse with Pipeline:
PTcells<- readRDS(file = "PIPSeq_Annotated_OnlyPT_v0823.rds")

DimPlot(PTcells)

# We only collect the PT cells
#CellType[CellType$cluster %in% c("1_1","0", "9","12","18", "19","3"),2] <- "PT" # "Proximal tubule"

PTcells @meta.data

# PTcells <- subset(scrna, subset = Raw_cell_type == "PT")
# 
# PTcells@meta.data
# # We then recluster the PT cells
# # recluster the cells
# PTcells <- SCTransform(PTcells, verbose = TRUE)
# PTcells <- RunPCA(PTcells,npcs = 5, verbose = TRUE)
# 
# # Run harmony for the PT cells
# PTcells <- RunHarmony(PTcells, 
# 				group.by.vars = c("DataSet"), 
# 				reduction = "pca", assay.use = "SCT", reduction.save = "harmony")
# PTcells <- RunUMAP(PTcells, dims = 1:5, verbose = TRUE, reduction = "harmony")
# PTcells <- FindNeighbors(PTcells, dims = 1:5,  verbose = TRUE, reduction = "harmony")
# 
# PTcells<- FindClusters(PTcells,  verbose = TRUE, resolution = 0.3)
# 
# PTcellsDim<- DimPlot(PTcells,label = T)
# PTcellsDim
# ggsave(filename = "PTcellsDim.pdf", plot = PTcellsDim, width = 8, height = 6)
# 
# PTcellsDimSplit<-DimPlot(PTcells, split.by = "DataSet",label = T)
# PTcellsDimSplit
# ggsave(filename = "PTcellsDimSplit.pdf", plot = PTcellsDimSplit, width = 24, height = 6)
# change the levels

Idents(PTcells)<-
# reorder the levels
ordered(Idents(PTcells), levels=rev(levels(Idents(PTcells))))

```

# Generate the figure for the PT
```{r}
# we only select the control:
PTcellControls  <- subset(PTcells, subset= (DataSet == "0DPI"))
PTcells@meta.data %>% head()
DimPlot(PTcellControls)

S1_S3_Markers<- c("Lrp2","Aqp1","Slc34a1","Ggt1","Atp1a1","Atp1b1","Slc5a2","Slc5a12","Slc22a8","Slc4a4","Slc13a3","Slc13a2","Slc22a6","Slc13a1","Slc22a2","Cubn","Slc22a30","Slc7a12","Slc22a7","Slc7a13","Aqp7")
S1_S3MarkerDotPlot<-DotPlot(PTcells, features =S1_S3_Markers,dot.min = 0.005, col.min = -6,
        col.max = 2, cols="RdBu")  + guides(color = guide_colorbar(title = 'AverExp'),
         size = guide_legend(title = "PercExp")) +  RotatedAxis()  
S1_S3MarkerDotPlot
# 
ggsave("S1_S3MarkerDotPlot_v0226.pdf",plot = S1_S3MarkerDotPlot, height = 3.5, width = 7)

S1_S3MarkerDotPlotControl<-DotPlot(PTcellControls, features =S1_S3_Markers,dot.min = 0.005, 
     cols="RdBu")  + guides(color = guide_colorbar(title = 'AverExp'),
         size = guide_legend(title = "PercExp")) +  RotatedAxis()  
S1_S3MarkerDotPlotControl
# 
ggsave("S1_S3MarkerDotPlotControl_v0226.pdf",plot = S1_S3MarkerDotPlotControl, height = 3.5, width = 6)

# Final Injury markers:
FinalInjuryMarkers<- c("Havcr1","Lcn2","Clu","Nrg1","Slc5a2","Agt", "Spp1", "Fn1","C3","Dab2","Vcam1","Kcnip4","Smad1","Sema5a","Dcdc2a","Ypel2","Hsp90aa1", "Hsp90ab1","Hspd1","Hif1a","Hmox1","Defb1","Lyz2","Nfkbia","Il1b","Ccl2")
FinalInjuryMarkersDotPlot <-DotPlot(PTcells, features =FinalInjuryMarkers,dot.min = 0.005, cols="RdBu")  + guides(color = guide_colorbar(title = 'AverExp'),
         size = guide_legend(title = "PercExp")) +  RotatedAxis()  

ggsave("FinalInjuryMarkersDotPlotControl_v0226.pdf",plot = FinalInjuryMarkersDotPlot, height = 4, width = 7)
FinalInjuryMarkersDotPlot
# Reduced PT markers
c(Lrp2,Aqp1, Slc34a1 )

# 
MetabolicMarkers<-c("Slc22a6", "Slc22a8", "Slc6a19", "Slc22a12", "Slc13a3", "Slc9a3", "Slc1a1","Ldha","Ldhd")

MetabolicMarkersDotPlot <-DotPlot(PTcells, features =MetabolicMarkers,dot.min = 0.005, cols="RdBu")  + guides(color = guide_colorbar(title = 'AverExp'),
         size = guide_legend(title = "PercExp")) +  RotatedAxis()  

ggsave("MetabolicMarkersDotPlotControl_v0226.pdf",plot = MetabolicMarkersDotPlot, height = 4, width = 5)

# EMT regulation marker
EMTMarker <- c("Tgfb1", "Notch1", "Wnt1", "Wnt3a","Hes1", "Ctnnb1","Shh","Gli1","Gli2", "Itgb1", "Itga5","Apoe","Spp1","Krt17","Acta2")

EMTMarkerDotPlot <-DotPlot(PTcells, features =EMTMarker,dot.min = 0.005, cols="RdBu")  + guides(color = guide_colorbar(title = 'AverExp'),
         size = guide_legend(title = "PercExp")) +  RotatedAxis()  
EMTMarkerDotPlot
```

# #####################################
## generate the Trajectories of PT cells using monocle2, instead of monocle3
# #####################################
# 2.2 Prepared cds the object we only select the S3 cells
```{r}
# transfer Seurat object to cellDataset object

# build cds object
# set up the pathway
Pyseudotime_S3_Dir<- paste0(PyseudotimeDir, "Pyseudotime_S3/")
setwd(Pyseudotime_S3_Dir)
PT_S3cells <- subset(PTcells, subset= (seurat_clusters %in% c(5,6) ))

# the expression
PT_S3cells_expr_matrix = LayerData(PT_S3cells, layer  = "counts")

# check expression matrix:

# Cell meta annotation -- phenotype
p_data <- PT_S3cells@meta.data 
head(p_data)
rownames(PT_S3cells_expr_matrix)
# Gene meta annotation
f_data<- data.frame(gene_short_name = rownames(PT_S3cells_expr_matrix), row.names = rownames(PT_S3cells_expr_matrix))
f_data
# UMIs or read ounts are better modele with the negative biomial.
pd <- new("AnnotatedDataFrame", data = p_data)
fd <- new("AnnotatedDataFrame", data = f_data)
PT_S3cells_expr_matrix

CDS <- monocle::newCellDataSet(as.matrix(PT_S3cells_expr_matrix), 
                       phenoData = pd, 
                       featureData = fd,
                       expressionFamily=negbinomial.size())
CDS
CDS <- estimateSizeFactors(CDS)
CDS <- estimateDispersions(CDS)

# quality control:
## 起初是 24582 features, 768 samples 
#---------首先是对基因的过滤-------------
CDS <- detectGenes(CDS, min_expr = 0.1)
print(head(CDS@featureData@data))
expressed_genes <- row.names(subset(CDS@featureData@data,
                                    num_cells_expressed >= 5))
length(expressed_genes)
colnames(phenoData(CDS)@data)


# step1：dispersionTable()

disp_table <- dispersionTable(CDS)
unsup_clustering_genes <- subset(disp_table, 
                                 mean_expression >= 0.1)
CDS <- setOrderingFilter(CDS, unsup_clustering_genes$gene_id)
CDS
plot_ordering_genes(CDS) 
# 图中黑色的点就是被标记出来一会要进行聚类的基因
CDS[expressed_genes,]
# step2 plot pc variance explained
plot_pc_variance_explained(CDS, return_all = F) # norm_method='log'

## Trajactory step 1: choose genes that define a cells' progress that compare the infection vs noninfection
diff_test_res <- differentialGeneTest(CDS[expressed_genes,],
              fullModelFormulaStr = "~Condition")

ordering_genes <- row.names (subset(diff_test_res, qval < 0.01))

CDS <- setOrderingFilter(CDS, ordering_genes)
plot_ordering_genes(CDS)

# reduce data dimention using DDRTree 
CDS <- reduceDimension(CDS, max_components = 2,
    method = 'DDRTree')
# trajectory step3: order cells along the trajectory
CDS <- orderCells(CDS)


pdf()
plot_cell_trajectory(CDS, color_by = "SCT_snn_res.0.3", cell_size = 0.5)
plot_cell_trajectory(CDS, color_by = "DataSet",cell_size=0.5)
?plot_cell_trajectory
# order by 


# "State" is just Monocle's term for the segment of the tree. The function below is handy for identifying the State which contains most of the cells from time zero. We can then pass that to orderCells:
unique(CDS@phenoData@data$SCT_snn_res.0.3)
T0_counts <- table(CDS@phenoData@data$SCT_snn_res.0.3, CDS@phenoData@data$DataSet)[,"0DPI"]
as.numeric(names(T0_counts)[which
          (T0_counts == max(T0_counts))])
table(CDS@phenoData@data$SCT_snn_res.0.3, CDS@phenoData@data$DataSet)[,"0DPI"]
GM_state <- function(CDS){
  if (length(unique(CDS@phenoData@data$SCT_snn_res.0.3)) > 1){
    T0_counts <- table(CDS@phenoData@data$SCT_snn_res.0.3, CDS@phenoData@data$DataSet)[,"0DPI"]
    return(as.numeric(names(T0_counts)[which
          (T0_counts == max(T0_counts))]))
  } else {
    return (1)
  }
}
GM_state(CDS)
#CDS2 <- orderCells(CDS, root_state = 1)
plot_cell_trajectory(CDS, color_by = "Pseudotime")


# 
BEAM_res <- BEAM(CDS, branch_point = 1, cores = 1)
BEAM_res <- BEAM_res[order(BEAM_res$qval),]
BEAM_res <- BEAM_res[,c("gene_short_name", "pval", "qval")]







# normalize and preproces the data
cds <- preprocess_cds(pre_cds) #标准化+PCA降维
plot_pc_variance_explained(cds)
# remove batch effects
## Step 2: Remove batch effects with cell alignment
cds <- align_cds(cds, alignment_group = "DataSet")

```

# 2.2 Umap by Monocle3
```{r}
#  Step 3: Reduce the dimensions using UMAP
cds <- reduce_dimension(cds)
## Step 4: Cluster the cells
cds <- cluster_cells(cds)

#plot_cells(cds, label_groups_by_cluster=FALSE,  color_cells_by = "partition")

head(cds@int_colData$reducedDims$UMAP)

plot_cells(cds, reduction_method="UMAP", 
           show_trajectory_graph = FALSE,
           label_cell_groups = FALSE, 
           color_cells_by="SCT_snn_res.0.3")
dev.off()
# UMAP by Seurat
seurat_umap <- Embeddings(PT_S3cells, reduction = "umap")[colnames(cds),]
cds@int_colData$reducedDims$UMAP <- seurat_umap
head(cds@int_colData$reducedDims$UMAP)
plot_cells(cds, reduction_method="UMAP", 
           show_trajectory_graph = FALSE,
           label_cell_groups = FALSE, 
           color_cells_by="SCT_snn_res.0.3")

```

# Draw the monocle state
```{r}
#分群(类似monocle的State)

#cds <- cluster_cells(cds)

#预测轨迹
cds <- learn_graph(cds)
#交互式确定root节点，可以选择多个。我这里选择了一个
cds <- order_cells(cds) 

PT_pseudotime <-plot_cells(cds, color_cells_by = "pseudotime", 
           label_cell_groups = FALSE, 
           label_leaves = TRUE,  
           label_branch_points = FALSE)
PT_pseudotime
ggsave(filename = "PT_pseudotime_MonocaCluster_initial_v02122025.pdf", plot = PT_pseudotime, width = 4, height = 3)


```
# without any choose root
```{r}
#分群(类似monocle的State)
### Step 5: Learn a graph
cds <- cluster_cells(cds)

#预测轨迹
cds <- learn_graph(cds)
#交互式确定root节点，可以选择多个。我这里选择了一个
#cds <- order_cells(cds) 
# a helper function to identify the root principal points:
get_earliest_principal_node <- function(cds, time_bin="0DPI"){
  cell_ids <- which(colData(cds)[, "DataSet"] == time_bin)
  closest_vertex <-
  cds@principal_graph_aux[["UMAP"]]$pr_graph_cell_proj_closest_vertex
  closest_vertex <- as.matrix(closest_vertex[colnames(cds), ])
  root_pr_nodes <-
  igraph::V(principal_graph(cds)[["UMAP"]])$name[as.numeric(names
  (which.max(table(closest_vertex[cell_ids,]))))]
  
  root_pr_nodes
}
cds <- order_cells(cds, root_pr_nodes=get_earliest_principal_node(cds))


PT_S3cells_pseudotime <-plot_cells(cds, color_cells_by = "pseudotime", 
           label_cell_groups = FALSE, 
           label_leaves = TRUE,  
           label_branch_points = FALSE,graph_label_size=1.5)
PT_S3cells_pseudotime
ggsave(filename = "PT_S3cells_pseudotime_MonocaCluster_V02122025.pdf", plot = PT_S3cells_pseudotime, width = 4, height = 3)



```


```{r}
# Determine the psedudotime related genes
Track_genes <- graph_test(cds, neighbor_graph="principal_graph")

Track_genes %>% head()

```

# plot the expression of interesting genes during the PT pseudotime
```{r}

# re-order the tracked genes by the q value and morans I
Track_genes <- Track_genes[,c(5,2,3,4,1,6)] %>% 
  dplyr::arrange(desc(morans_I),q_value)

# Plot some interesting genes for the PT pseudotime : Top 2 genes, Napsa, Kap, Ttr, Igfbp7, Havcr1 and Prom1
KapTrack <- plot_genes_in_pseudotime(cds[Track_genes$gene_short_name[1],] , 
                         min_expr=0.5)
ggsave(filename = "PT_pseudotime_KapTrack.pdf", plot = KapTrack, width = 5, height = 3)
NapsaTrack <- plot_genes_in_pseudotime(cds[Track_genes$gene_short_name[2],] , 
                         min_expr=0.5)
ggsave(filename = "PT_pseudotime_NapsaTrack.pdf", plot = NapsaTrack, width = 5, height = 3)

TtrTrack <- plot_genes_in_pseudotime(cds["Ttr",] , 
                         min_expr=0.5)
ggsave(filename = "PT_pseudotime_TtrTrack.pdf", plot = TtrTrack, width = 5, height = 3)

Igfbp7Track <- plot_genes_in_pseudotime(cds["Igfbp7",] , 
                         min_expr=0.5)
ggsave(filename = "PT_pseudotime_Igfbp7Track.pdf", plot = Igfbp7Track, width = 5, height = 3)

Track_genes$gene_short_name[1:5]


Track_genes$gene_short_name[2]
Track_genes$gene_short_name[1]
Havcr1Track <- plot_genes_in_pseudotime(cds["Havcr1",] , 
                         min_expr=0.5)

ggsave(filename = "PT_pseudotime_Havcr1Track.pdf", plot = Havcr1Track, width = 5, height = 3)

# For the 
Prom1Track <- plot_genes_in_pseudotime(cds["Prom1",],min_expr=0.5 )
ggsave(filename = "PT_pseudotime_Prom1Track.pdf", plot = Prom1Track, width = 5, height = 3)

FeaturePlot(PT_S3cells, features = "Havcr1")

```

# choose the top signifcant for visualization
```{r}
diff_pseudo_gene <- Track_genes %>% 
  dplyr::arrange(q_value) %>%
  # remove the genes with mitochondrion
  filter(!grepl('^mt-|Hbb-', gene_short_name)) %>%
  rownames() %>% head(60)

# we ignore the mitochondria genes



diff_pseudo_gene

# generate the heatmap for those genes

diff_pseudo_gene.matrix <- exprs(cds)[match(diff_pseudo_gene,rownames(rowData(cds))),order(pseudotime(cds))]

diff_pseudo_gene.matrix <- t(apply(diff_pseudo_gene.matrix,1,function(x){smooth.spline(x,df=3)$y}))
diff_pseudo_gene.matrix <- t(apply(diff_pseudo_gene.matrix,1,function(x){(x-mean(x))/sd(x)}))
rownames(diff_pseudo_gene.matrix) <- diff_pseudo_gene;

#pheatmap(diff_pseudo_gene.matrix)

# because the plot_pseudotime_heatmap no longer have, we used the complexheatmap to draw the figure
# Reference: https://github.com/cole-trapnell-lab/monocle-release/issues/295
pdf("PT_pseudotime_psudotimeGenes.pdf", height = 6, width = 8)
htkm <- Heatmap(
  diff_pseudo_gene.matrix,
  name    = "z-score",
  col     = colorRamp2(seq(from=-2,to=2,length=11),rev(brewer.pal(11, "Spectral"))),
  show_row_names  = TRUE,
  show_column_names = FALSE,
  row_names_gp  = gpar(fontsize = 6),
  km = 8,
  row_title_rot = 0,
  use_raster=TRUE,
  cluster_rows  = TRUE,
  cluster_row_slices = FALSE,
  cluster_columns   = FALSE)

print (htkm)
dev.off()
#ggsave(filename = "PT_pseudotime_psudotimeGenes.pdf", plot = htkm, width = 8, height = 6)


#Ward.D2 Hierarchical Clustering
pdf("PT_pseudotime_psudotimeGenes_Hierarchicalcluster.pdf", height = 7, width = 6)
hthc <- Heatmap(
  diff_pseudo_gene.matrix,
  name                         = "z-score",
  col                          = colorRamp2(seq(from=-2,to=2,length=11),rev(brewer.pal(11, "Spectral"))),
  show_row_names               = TRUE,
  show_column_names            = FALSE,
  row_names_gp                 = gpar(fontsize = 6),
  clustering_method_rows = "ward.D2",
  clustering_method_columns = "ward.D2",
  row_title_rot                = 0,
  use_raster= TRUE,
  cluster_rows                 = TRUE,
  cluster_row_slices           = FALSE,
  cluster_columns              = FALSE)

print(hthc)
dev.off()

cds["Havcr1",] %>% head()
# Generate the Dotplot for these genes
plot_genes_in_pseudotime(cds[c("Havcr1"),] , 
                         min_expr=0.5)

DotPlot(PT_S3cells, features =diff_pseudo_gene ) +RotatedAxis()

DotPlot(PT_S3cells, features =c("Spp1","Havcr1","Itgb1","Top2a",
                             "Prom1","Pdgfb","Defb1","Fn1","Col6a1"), col.min = -0.5 ) +RotatedAxis()

FeaturePlot(PT_S3cells, features = c("Lcn2","Defb1","Egf","Havcr1"))
# the following no longer have 

Track_genes
# p = plot_pseudotime_heatmap(cds[diff_pseudo_gene,], 
#                         num_clusters = 3,  # default 6
#                         return_heatmap=T)
# 

```




# generate the subclusters of PT, DCT, IC, PC
```{r}
# dividing into cycling, transitioning, adap- tive (successful or maladaptive repair) and degenerative (damaged or stressed). 
# cycling: Mki67
# Early Injury: Cdh13, Cdh6, Havcr1
# Late Injury: Ccl2, Gm17268, Cald1
# conserved: Slc13a1, Slc5a2,  Slc7a13, Cyp7b1



# Panoptosis
# Il1b, MLKL, Gsdmd,Ripk3

# Fibrosis 
# Fn1, Col1a1, Col3a1, Tgfb1
# adaptive
# VCAM1, DCDC2 and HAVCR1, C3, ICAM1
# VCAM1 PROM1 ITGB8
# Vcam1, Havcr1, Dcdc2, Icam1, Prom1, ITgb8

#degenerative
# SPP1, CST3, CLU and IGFBP7, APOE ALDOB
# B2M S100A6
# Spp1, Cst3, GDF15,Clu, Igfbp7, Apoe, Aldob, B2m, S100a6
# agionegious PEC,
# EGFR, VEGF, Cdh5

# Egfr, Vegf, Cdh5
KidneyStatuesMarkers<- c("Slc13a1", "Slc5a2", "Slc7a13", "Cyp7b1","Mki67","Cdh13", "Cdh6", "Havcr1","Ccl2", "Gm17268", "Cald1")

KidneyStatuesTypeMarkers<- c("Il1b", "Mlkl", "Gsdmd","Ripk3","Fn1", "Col1a1", "Col3a1", "Tgfb1","Vcam1", "Havcr1", "Icam1", "Prom1", "Spp1", "Cst3","Gdf15", "Clu", "Igfbp7", "Apoe", "Aldob", "B2m", "S100a6")

DotPlot(scrna, features =  KidneyStatuesMarkers, col.min = -0.5) +RotatedAxis()
DotPlot(scrna, features =  KidneyStatuesTypeMarkers, col.min = -0.5) +RotatedAxis()


for (i in KidneyStatuesMarkers){
# 
  FeaturePlots<-FeaturePlot(scrna, features =  i, split.by = "DataSet" ) +RotatedAxis()
  ggsave(paste0(Outdir,"/KidneyStatuesMarkers/", i, "_Feature_GeneMarkers_Annoatation.pdf"), plot =FeaturePlots, height =6, width = 14)
}

for (i in KidneyStatuesTypeMarkers){
# 
  FeaturePlots<-FeaturePlot(scrna, features =  i, split.by = "DataSet" ) +RotatedAxis()
  ggsave(paste0(Outdir,"/KidneyStatuesTypeMarkers/", i, "_Feature_GeneMarkers_Annoatation.pdf"), plot =FeaturePlots, height =6, width = 14)
}


# with the inflammation markers

# with the fibrosis markers

# with the apoptosis markers

# with the necrosis markers

# with the endothelial markers


```


